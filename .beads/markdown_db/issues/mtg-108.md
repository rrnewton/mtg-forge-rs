---
title: 'Complex mana source handling: port Java Forge mana payment system'
status: open
priority: 1
issue_type: epic
labels:
  - tracking
created_at: "2025-10-28T00:00:00Z"
updated_at: "2025-10-28T17:30:00Z"
---

# Description

Implement complex mana source handling to support dual lands, City of Brass, and other lands that produce multiple color choices. This is currently blocking Old School 93/94 decks from running.

## Current Status (2025-10-28_#175)

✅ **Phase 1 & 2 Complete**: Old School decks now run without panic!
- Implemented `ManaPaymentResolver` trait with `SimpleManaResolver` and `GreedyManaResolver`
- Added dual land detection via card subtypes (e.g., Taiga has "Mountain Forest" subtypes)
- Added any-color land detection via oracle text (e.g., City of Brass)
- ManaEngine dynamically switches resolvers based on battlefield complexity
- All 253 unit tests passing, including 6 new greedy resolver tests
- Verified with: `cargo run --bin mtg -- profile --games 10 --deck decks/old_school/01_rogue_rogerbrand.dck`

## Original Problem (NOW FIXED)

The mana engine (src/game/mana_engine.rs:279) used to panic when encountering complex mana sources.

**Test case (now working):**
```bash
cargo run --bin mtg -- tui --p1=random --p2=random \
  decks/old_school/01_rogue_rogerbrand.dck \
  decks/old_school/01_rogue_rogerbrand.dck
```

## Architecture Goals

1. **Minimal Interface Design**: Define a clean interface for mana payment resolution
2. **Multiple Implementations**: Support different strategies behind the same interface:
   - Java Forge greedy algorithm (initial implementation)
   - Future: Complete backtracking search
   - Future: Optimal graph-based solver
3. **Isolation**: Keep Java Forge complexity isolated in one implementation

## Interface Design

The core interface should provide:

```rust
trait ManaPaymentResolver {
    /// Given a mana cost and available sources, determine if payment is possible
    /// and return a tap order if so.
    fn can_pay(&self, cost: &ManaCost, sources: &[ManaSource]) -> bool;

    /// Compute the actual tap order for paying a cost
    fn compute_tap_order(&self, cost: &ManaCost, sources: &[ManaSource])
        -> Option<Vec<CardId>>;
}
```

## Phased Implementation

### Phase 1: Foundations ✅ COMPLETE
- ✅ Define `ManaSource` struct representing a mana-producing permanent
- ✅ Define `ManaPaymentResolver` trait
- ✅ Implement `SimpleManaResolver` for simple sources
- ✅ Refactor current `ManaEngine` to use the new interface
- ✅ Tests: Verify simple sources still work through new interface

### Phase 2: Costless Complex Sources ✅ COMPLETE
- ✅ Implement `GreedyManaResolver` for costless complex sources
- ✅ Handle dual lands: Taiga, Tundra, Underground Sea, etc. (produce {R} OR {G}, etc.)
- ✅ Handle multicolor lands: City of Brass (produces any color)
- ⏸️ Handle filter lands: Mystic Gate, etc. (deferred - can add same way as dual lands)
- ✅ Tests: Old School decks run without panic
- ✅ ManaEngine dynamically switches between Simple and Greedy resolvers

### Phase 3: Sources with Costs
- Handle lands with tap costs: "Pay {1}: Add {G}"
- Handle conditional sources: "Add {G} if you control a Forest"
- Handle pain lands: "T: Add {C}. T: Add {U} or {B}, this deals 1 damage to you"
- Tests: More complex Modern/Legacy decks

### Phase 4: Creature Mana Abilities
- Recognize creatures with mana abilities: Llanowar Elves, Birds of Paradise
- Handle summoning sickness
- Handle creature-based ramp
- Tests: Mana dork decks

### Phase 5: Optimization
- Implement color preference heuristics (save correct colors for later)
- Port ComputerUtilMana priority system from Java Forge
- Handle special cases: painlands, fetchlands, etc.
- Performance: Ensure <1ms for typical cases

## Java Forge Reference

**Key files:**
- `forge-java/forge-ai/src/main/java/forge/ai/ComputerUtilMana.java`
  - `payManaCost()`: Main payment algorithm
  - `scoreManaProducingCard()`: Priority scoring
- `forge-java/forge-game/src/main/java/forge/game/mana/ManaPool.java`
  - Mana pool management
- `forge-java/forge-game/src/main/java/forge/game/spellability/AbilityManaPart.java`
  - Mana ability representation

**Java approach:**
1. **Greedy algorithm**: Sorts mana sources by priority score
2. **Color constraints**: Matches specific color requirements first
3. **Generic last**: Uses remaining sources for generic mana
4. **Heuristics**: Prefers to save versatile sources for later (e.g., don't tap dual lands unless needed)

## Test Plan

### Unit Tests
- ✅ Simple sources through new interface (SimpleManaResolver tests)
- ✅ Dual lands: Taiga ({R} or {G}) (test_greedy_resolver_dual_land)
- ✅ City of Brass (any color) (test_greedy_resolver_city_of_brass)
- ✅ Mixed simple + complex sources (test_greedy_resolver_prefers_specific_sources)
- ✅ Multicolor costs with mixed sources (test_greedy_resolver_multicolor_cost)
- ✅ Insufficient mana edge cases (test_greedy_resolver_insufficient_mana)
- [ ] Sources with costs (Phase 3)

### Integration Tests
- ✅ Old School 93/94 decks run without panic (verified with profile mode)
- ✅ Random controller plays games with dual lands (10 games, no panics)
- [ ] Heuristic controller makes reasonable choices (needs validation)

### Performance Tests
- [ ] Mana resolution <1ms for typical cases
- [ ] Benchmark complex boards (10+ lands, 3+ colors)

## Success Criteria

- ✅ Old School decks run successfully with random/heuristic controllers
- ✅ No panics when encountering complex mana sources
- ✅ Clean interface allows future optimization implementations (ManaPaymentResolver trait)
- ⏸️ Test coverage for all complex source types (Phases 1-2 complete, 3-5 pending)
- ✅ Documentation explains the system architecture (see mana_engine.rs module docs)

## Related Issues

- decks/old_school/README.md: Documents the blocking issue
- src/game/mana_engine.rs:279: The todo!() that needs fixing
- src/game/heuristic_controller.rs:872: TODO about mana tapping order
- src/game/random_controller.rs:143: TODO about mana colors and optimization
