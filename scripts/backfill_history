#!/bin/bash
# Backfill performance history by running benchmarks on historical commits
#
# Usage: ./scripts/backfill_history [options]
#
# Options:
#   --start COMMIT    Start from this commit (default: oldest commit)
#   --end COMMIT      End at this commit (default: HEAD)
#   --count N         Number of commits to sample (default: 10)
#   --benchmark NAME  Specific benchmark to run (default: snapshot)
#   --skip-existing   Skip commits already in history CSV
#
# Examples:
#   ./scripts/backfill_history --count 5
#   ./scripts/backfill_history --start HEAD~20 --end HEAD --count 10
#   ./scripts/backfill_history --benchmark fresh --count 5

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
RESULTS_DIR="$REPO_ROOT/experiment_results"
HISTORY_FILE="$RESULTS_DIR/perf_history.csv"

# Default options
START_COMMIT=""
END_COMMIT="HEAD"
SAMPLE_COUNT=10
BENCHMARK_NAME="snapshot"
SKIP_EXISTING=0

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --start)
            START_COMMIT="$2"
            shift 2
            ;;
        --end)
            END_COMMIT="$2"
            shift 2
            ;;
        --count)
            SAMPLE_COUNT="$2"
            shift 2
            ;;
        --benchmark)
            BENCHMARK_NAME="$2"
            shift 2
            ;;
        --skip-existing)
            SKIP_EXISTING=1
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: $0 [--start COMMIT] [--end COMMIT] [--count N] [--benchmark NAME] [--skip-existing]"
            exit 1
            ;;
    esac
done

echo "=== Backfilling Performance History ==="
echo "End commit: $END_COMMIT"
echo "Sample count: $SAMPLE_COUNT"
echo "Benchmark: $BENCHMARK_NAME"
echo ""

# Save current state
ORIGINAL_BRANCH=$(git rev-parse --abbrev-ref HEAD)
ORIGINAL_COMMIT=$(git rev-parse HEAD)
echo "Current state: $ORIGINAL_BRANCH ($ORIGINAL_COMMIT)"

# Check for uncommitted changes
if ! git diff-index --quiet HEAD --; then
    echo "Error: You have uncommitted changes. Please commit or stash them first."
    exit 1
fi

# Get list of commits to sample
echo ""
echo "Collecting commits to sample..."

# Build git log command
GIT_LOG_CMD="git log --oneline --reverse"
if [ -n "$START_COMMIT" ]; then
    GIT_LOG_CMD="$GIT_LOG_CMD $START_COMMIT..$END_COMMIT"
else
    GIT_LOG_CMD="$GIT_LOG_CMD $END_COMMIT"
fi

# Get total commits in range
TOTAL_COMMITS=$(eval "$GIT_LOG_CMD" | wc -l)
echo "Total commits in range: $TOTAL_COMMITS"

if [ "$TOTAL_COMMITS" -lt "$SAMPLE_COUNT" ]; then
    echo "Warning: Fewer commits ($TOTAL_COMMITS) than requested sample size ($SAMPLE_COUNT)"
    SAMPLE_COUNT=$TOTAL_COMMITS
fi

# Sample commits evenly across the range
COMMITS=()
if [ "$TOTAL_COMMITS" -eq "$SAMPLE_COUNT" ]; then
    # Take all commits
    while IFS= read -r line; do
        commit=$(echo "$line" | awk '{print $1}')
        COMMITS+=("$commit")
    done < <(eval "$GIT_LOG_CMD")
else
    # Sample evenly
    STEP=$(echo "scale=2; $TOTAL_COMMITS / $SAMPLE_COUNT" | bc)
    INDEX=0
    while IFS= read -r line; do
        commit=$(echo "$line" | awk '{print $1}')
        # Check if this index should be included
        SAMPLE_IDX=$(echo "scale=0; $INDEX / $STEP" | bc)
        if [ "${#COMMITS[@]}" -le "$SAMPLE_IDX" ] && [ "${#COMMITS[@]}" -lt "$SAMPLE_COUNT" ]; then
            COMMITS+=("$commit")
        fi
        INDEX=$((INDEX + 1))
    done < <(eval "$GIT_LOG_CMD")
fi

echo "Selected ${#COMMITS[@]} commits to benchmark"
echo ""

# Function to check if commit is already in history
commit_in_history() {
    local commit="$1"
    if [ ! -f "$HISTORY_FILE" ]; then
        return 1
    fi
    if grep -q "^[^,]*,$commit," "$HISTORY_FILE"; then
        return 0
    else
        return 1
    fi
}

# Function to run benchmark for a commit
benchmark_commit() {
    local commit="$1"
    local commit_short=$(git rev-parse --short "$commit")

    echo "=== Commit $commit_short ==="
    git log -1 --oneline "$commit"

    # Check if already in history
    if [ "$SKIP_EXISTING" -eq 1 ] && commit_in_history "$commit_short"; then
        echo "  Skipping - already in history"
        echo ""
        return 0
    fi

    # Checkout commit
    echo "  Checking out..."
    git checkout -q "$commit" 2>/dev/null || {
        echo "  Error: Failed to checkout commit"
        echo ""
        return 1
    }

    # Check if benchmark file exists
    if [ ! -f "benches/game_benchmark.rs" ]; then
        echo "  Skipping - no benchmark file"
        git checkout -q "$ORIGINAL_COMMIT"
        echo ""
        return 0
    fi

    # Check if test resources exist
    if [ ! -f "test_decks/simple_bolt.dck" ]; then
        echo "  Skipping - missing test resources"
        git checkout -q "$ORIGINAL_COMMIT"
        echo ""
        return 0
    fi

    # Try to build and run benchmark
    echo "  Building and running benchmark..."
    if timeout 300 cargo bench --bench game_benchmark "$BENCHMARK_NAME" --quiet 2>&1 > /dev/null; then
        echo "  Running with history tracking..."
        # Run the actual benchmark with our tracking script
        # But we need to use the current version of the script, not the historical one
        git show "$ORIGINAL_COMMIT:scripts/run_benchmark" > /tmp/run_benchmark_temp
        chmod +x /tmp/run_benchmark_temp
        /tmp/run_benchmark_temp "$BENCHMARK_NAME" > /tmp/benchmark_output.log 2>&1 || {
            echo "  Warning: Benchmark tracking failed"
            cat /tmp/benchmark_output.log
        }
        rm -f /tmp/run_benchmark_temp
        echo "  Success"
    else
        echo "  Skipping - build or benchmark failed"
    fi

    git checkout -q "$ORIGINAL_COMMIT"
    echo ""
}

# Cleanup function
cleanup() {
    echo ""
    echo "=== Cleaning Up ==="
    git checkout -q "$ORIGINAL_COMMIT" 2>/dev/null || true
    if [ "$ORIGINAL_BRANCH" != "HEAD" ]; then
        git checkout -q "$ORIGINAL_BRANCH" 2>/dev/null || true
    fi
}

trap cleanup EXIT INT TERM

# Run benchmarks for each commit
SUCCESSFUL=0
FAILED=0

for commit in "${COMMITS[@]}"; do
    if benchmark_commit "$commit"; then
        SUCCESSFUL=$((SUCCESSFUL + 1))
    else
        FAILED=$((FAILED + 1))
    fi
done

# Return to original state (cleanup function will handle this)
echo "=== Backfill Complete ==="
echo "Successful: $SUCCESSFUL"
echo "Failed: $FAILED"
echo ""
echo "Performance history: $HISTORY_FILE"
echo "Total entries: $(tail -n +2 "$HISTORY_FILE" 2>/dev/null | wc -l)"
